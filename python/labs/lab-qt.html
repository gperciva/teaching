<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Strict//EN"
"http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>Getting Ready II - Qt GUI</title>
<link rel="stylesheet" href="../eeip1.css">
</head>
<body>

<a href="../index.html">Back to main</a>

<h1>
	Getting Ready for the Grand Challenge II<br/>
	Building a Graphics User Interface using PyQt
</h1>

<div class="center">
Exercises:

<ul style="list-style-type:none;">
<li class="mines">
19. Thinking about GUIs
</li><li class="mines">
20. 
</li>
</ul>
</div>

<div class="task">
<h3 style="background:#f090e0">Thinking about GUIs...</h3>
<h2>Objects or co-routines?</h2>
<p>
Sometimes, it's important to think hard, and work out if
what you're writing in your code isn't more for the benefit
of the computer than for you. This is one of those times.
</p>
<p>
CPUs have hardware support for subroutines. So languages like
C, which is about as "close to the metal" as you can get
without assembler, base their whole modus operandi on breaking
up larger programs into a bunch of subroutines, which 
pass arguments around and reserve local memory.
CPUs are built with (one or more) stacks which make
this easy for the compiler and fast to run. But
when a program gets bigger, and particularly when
it has to respond to asynchronous events, this isn't
necessarily the easiest way to express things.
</p>
<p>
Donald Knuth, a renowned computer scientist, famously
described subroutines as "special cases of ... coroutines."
[<i>Knuth, Donald Ervin (1997). Fundamental Algorithms. The Art of Computer Programming. 1
(3rd ed.). Addison-Wesley. Section 1.4.2: Coroutines, pp. 193–200. ISBN 0-201-89683-4.)</i>]
So what's a coroutine? Here's an example.
</p>
<p>
Suppose you wish to simulate those ticket dispensers you
get in up-market delicatessens. Anybody can walk in and
take a ticket; every time a ticket is dispensed, the number
is one bigger than the previous ticket. In our software version,
I'm going to add the facility to skip ahead. Normally we'll
pass 0 and just get the next number; otherwise we can pass
a number of tickets to skip (these numbers are lost forever).
</p>
<div class="left">
<h5>Creating an object</h5>
<pre class="code">
# Turn counting with an Object
class TurnCounter:

    # Initialise the sequence counter to 0.
    def __init__(self):
        self._seq = 0;
        
    # Return the next in seqence,
    # skipping as required.    
    def get(self, skip):
        ticket = self._seq
        self._seq += 1 + skip
        return ticket
</pre>
<p>
We'd then create an instance of the object (thus
initializing its state) and repeatedly call
<code>get(0)</code> to receive tickets.
</p>
<pre class="example">
In [31]: tc=TurnCounter()
In [32]: tc.get(0)
Out[32]: 0
In [33]: tc.get(0)
Out[33]: 1
In [34]: tc.get(1)
Out[34]: 3
</pre>
</div>
<div class="right">
<h5>Creating a coroutine</h5>
<pre>
# Turn counting with a co-routine
# (also called a generator object in Python)
def turn_counter():
    # Our state variable local to this function
    _seq = 0
    
    while True:
        # Pass back the sequence count to our
        # coroutine, and receive the next skip value
        skip = yield _seq
        # Do some processing and loop forever
        _seq += 1 + skip
</pre>
<p>
The clue's in the name: a coroutine isn't subordinate to its caller
like a subroutine. Subroutines get passed variables, process them
and return a value. Any information stored in the
subroutine's local variables is lost when the subroutine
returns.
</p>
<p>
Coroutines get created, and are allowed to proceed by the routine
that created them. The coroutine then takes the conn until
it's ready to pass control back to the original routine
&mdash; <em>its</em> coroutine &mdash; using the <code>yield</code>
command.
</p>
<p>
Execution now passes back to the original coroutine until it
decides to yield control back again. It can do that by invoking
<code>next()</code> with the coroutine as an argument, or to
send data to the coroutine, using the coroutine's <code>send()</code>
method.  <code>send()</code> causes execution to continue after
the <code>yield</code> command which relinquished it, and with
the sent value being treated like returned data.
</p>
<p>
The important thing here is that the coroutine's state &mdash; its
local variables and so forth &mdash; remain intact with the same
values as they had when the thread of execution was yielded on
the previous occasion.
</p>
<pre class="example">
In [35]: tc = turn_counter()
In [36]: tc
Out[36]: <generator object turn_counter at 0x7f8b2011ddb0>
In [37]: next(tc)
Out[37]: 0
In [38]: tc.send(0)
Out[38]: 1
In [40]: tc.send(1)
Out[40]: 3
</pre>
<p>
Here we create a generator (coroutine) called tc. Python knows
it's a generator because its <code>def</code>inition contained
a <code>yield</code> statement. Then we run the coroutine
to the first <code>yield</code> with <code>next(tc)</code>
(<code>tc.send(None)</code> would have worked too). We get the
first ticket as a result. Then we as for two more tickets,
and the last time ask to skip one.
</p>
</div>
<div style="margin-bottom:0.5cm;overflow:hidden;text-align:right;clear:left">
<p style="display:inline-block;">Read this next ⇗</p>
<hr/>
</div>
<p>
So what's the benefit of the coroutine approach over using
an object? The answer is that to program well, you should
<em>say what you mean</em>. In the case of a single object
and a single coroutine, the difference between
the two methods of expression
aren't that obvious. But suppose there were many different
coroutines which became ready to run at different times
and that they all had arbitrary, equally important roles
in the overall program... choosing an object hierarchy and
deciding which object called which others might well be
syntactically opaque compared with an egalitarian collection
of coroutines. Check out Python&nbsp;>=3.4's
<a href="https://docs.python.org/3/library/asyncio-task.html#coroutines"><code>asyncio</code></a>
library (and keep reading to the end of
<a href="https://docs.python.org/3/library/asyncio-task.html#example-chain-coroutines">this
section</a>) for an example of how coroutines can simply
and elegantly organise different <strike>sub</strike>co-tasks
under the auspices of an event loop.
</p>
<p>
No imagine each of the coroutines belonged to different
graphic objects, each of which needs to communicate with
other objects at any time the user chooses to interact
with them. They can do this by communicating though
a single executive which can <code>gather</code> all
the information the waiting coroutines may (asynchronously)
yield. Does that sound like a GUI yet?
</p>
<p>
One last point to make is that what is being described here
is in no way "parallel processing". It is co-operative
multitasking. The coroutines get to keep the single
thread of execution until they yield it up.
Coroutines don't run in parallel (for example
on multiple cores of a modern CPU) but neither do they
impose the considerable overhead of starting a new process,
allocating resources and resynchronising the machine when
necessary. You can perform a 4096-point FFT on a single core
of a modern Intel processor faster than you can force
two threads on two different cores to synchronise.
Coroutines permit the expression of complex interactions
between entities handling asynchronous events in a
convenient way which is efficient for both the programmer
and the computer.
</p>
<p>
Coroutines feature big-time "under the hood" of the GUI
toolkit we're going to use in due course, and if you 
understand what they do, it will demystify what's going
on. We'll also fire up a separate thread of execution
which will jump to C++-space, permitting potentially
generally parallel execution, but Python makes sure it
will never execute code concurrently within a single
instance of its interpreter.
</p>
<p>
Now, about Graphic User Interfaces...
</p>
<br clear="both" />
<h2>GUI components: the MVC model</h2>
<p>
<div class="right" style="width:12cm;padding:8px">
<h5>Model View Controller interaction</h5>
<img src="MVC-basic.svg" style="width:100%"/><br/>
By Totallybradical - Own work, CC BY-SA 4.0, https://commons.wikimedia.org/w/index.php?curid=56162327
</div>
If you've learned one thing from this course, I hope it's
that you should design your program before writing a single
line of code. It's therefore appropriate at this juncture
to review the current thinking behind the design of modern
GUI systems.
</p>
<p>
GUI programs are generally composed from <em>Widgets</em> (the
generic name for buttons, text entry fields, spin-boxes,
sliders and other graphical components) assembled into
one or more <em>frames</em>. The widgets are positioned
by a <em>layout manager</em> whose job it is to construct
their spacing and size in accordance with the style rules
for the platform on which the program is running.
</p>
<p>
All <em>widget sets</em> will enable the programmer to
define new widgets, but the choice of a modern and popular
widget set makes it unlikely that it will ever be necessary
to do more than enhance the functionality of one of the
supplied widgets.
</p>
<p>
It is considered to be good design to split the interface up
into three aspects: the <em>model</em>, <em>view</em>
and <em>controller</em>.
</p>
<ul>
<li>The model determines the behaviour
of a widget in response to input and defines the information
available to the application program. It is independent of
the user interface. If the idea of the widget were
reimplemented in a non-graphical way, for example for
blind users, the model would remain unchanged.</li>
<li>The view is concerned with the presentation of
the widget to the user and hence determining to
an extent what input gestures take effect. The application
may supply different views depending upon the intended
platform: on a phone, a photo gallery might move to
the next image with a swipe, whereas on a workstation
it may accept a mouse click. The view will not be involved
in the interpretation of such gestures, only reporting
them.</li>
<li>The controller supplies the logic to connect the
model and the view. It can send commands to the model
to update its state ("next photo") and when instructed
by the model, sends the necessary commands to the view
to maintain the widget's consistency</li>
</ul>
<p>
Splitting the GUI into these three aspects ensures maximum
code reuse and enables consistency of behaviour across a
variety of access methods with as little code modification
(read "breaking") as possible. The diagram summarises the
interactions. The widget set will permit us to add ways for
the widget's controller to let the application program
know when something has happened.
</p>

<h4 style="background:#f090e0">...On to some programming</h4>
</div>


<br style="clear:both"/>
<a name="very-simple-swig">
<h2>Exercise 17: A Very Simple Example</h2>

<div class="left">
<h3>Background</h3>
<p>
We're going to use the Qt widget set to design a GUI program.
Qt (pronounced "Cute") is a cross-platform toolkit
written by Trolltech, and currently owned by
<a href="https://www.qt.io/">The Qt Company</a> in Finland.
It is dual licensed under both version&nbsp;3 of the
<a href="https://www.gnu.org/licenses/gpl-faq.html">GNU
Public License</a> and a proprietary licence which
permits distribution of software without the obligations
attached to GPLv3. This document is based on version&nbsp;5
of Qt.
</p>

<p>
Qt is written in C++, so the
<a href="http://doc.qt.io/qt-5/">documentation</a>
assumes that the reader will be creating classes
and calling methods from a C++ program.
We're going to use it via Python modules
created from the C++ API using SWIG. The top-level
Python module is called <em>PyQt5</em>. PyQt5 has its own 
<a href="http://pyqt.sourceforge.net/Docs/PyQt5/">documentation</a>
but for the most part, it simply instructs you
how to load the Python class and then simply
directs you to the Qt C++ documentation page.
</p>

<p>
At some time or another, you'll most likely be asked to
use some other GUI framework to write a program.
There's no good reason for that as there are a huge
number of reliable and large-scale applications
written with Qt, for example
<a href="http://www.muse-sequencer.org/" >MusE</a>,
<a href="http://www.rosegardenmusic.com/" >Rosegarden</a>,
<a href="https://musescore.org/" >MuseScore</a>,
<a href="http://frescobaldi.org/">Frescobali</a>,
<a href="https://kdenlive.org/">Kdenlive</a>,
<a href="http://pythonhosted.org/spyder/">Spyder</a>,
<a href="https://www.skype.com/en/">Skype</a>,
<a href="https://www.google.com/earth/">Google Earth</a>,
<a href="https://www.scribus.net/">Scribus</a>,
<a href="http://www.avid.com/sibelius" >Sibelius</a>,
<a href="https://www.videolan.org/vlc/" >VLC</a>
and <a href="https://www.spotify.com/uk/" >Spotify</a>'s client
to name but a few.
</p>

<p>
The Qt application usually consists of a <code>QApplication</code>
instance and one or more <code>QWidgets</code> which define the
visual appearance. Depending on the platform style guidelines,
the widget might consist of a framed window, a menu bar,
a toolbar, and an interaction area consisting of a variety
of widgets drawn from the familiar standard types (spin boxes,
editable and read-only text areas, images, sliders, push-buttons
and so on). An application might present the user with <em>dialogues</em>
in other windows during the course of its execution.
Such dialogues might be modal (grab the application's inputs
until it is dismissed) or not depending on the program's
requirements.
</p>

<p>
Once the widgets are created they can be laid out using
one of Qt's <em>layout managers</em>. This ensures that
window resizing causes the widgets to expand and/or
move around in an expected fashion. Several different
layout algorithms are available and one can be chosen
to suit the complexity of the GUI being designed.
The program will create a layout manager instance
and attach it to its window, then add widgets to
the layout manager. Layout managers may be nested
hierarchically. Having created, populated and laid-out
the window, its <code>show()</code> method can be
called to make it appear on the screen, and control
handed over to Qt's event-handling loop.
</p>

<p>
That's only half the story, however. If you want the
program to respond to user inputs, the widgets have
to inform the relevant functions of the application
when user-events happen to them. Different GUI
frameworks have different ways of doing this, and
the way Qt does it has been somewhat controversial
in the past. The idea is that <code>QObjects</code>
can emit <em>signals</em> to send information about
events to interested listeners and <em>slots</em>
to receive such information. Why is this controvertial?
Because the slots were implemented by <em>extending
the C++ language</em> and then running a
<em>metaobject compiler</em> on them to obtain a
compilable C++ file. This enraged the C++ standards
people and almost started a civil war. Consider the following
C++ code. It creates a window with a single button
(that bit's omitted for brevity) and changed the
button's label when it's clicked.
</p>

<pre class="example">
class MyWindow :
   public QWidget,
   public Ui::AMainWindow
{
   Q_OBJECT
public:
   explicit MyWindow(QWidget *parent = 0) :
       QWidget(parent)
   {
       // create the interface
       this->setupUi(this);

       // connect the signal to lambda
       // (using [this] to capture 
       // the object's this pointer)
       connect(theButton,
               &QPushButton::clicked,
               [this]() {
                   this->setString("Bye!");
               });
   }

public slots:
   void setString(QString text)
   {
       theButton->setText(text);
   }
};
</pre>

<p>
The <code>Q_OBJECT</code> gets expanded to include
the necessary "boiler-plate", but the main bone
of contention is the <code>public slots:</code>
access specifier. <code>public slots:</code> isn't
valid C++: it's expanded by the MOC to generate
the necessary public function which can accept
signals. Then then <code>QObject</code>'s
<code>connect</code> function is used to cause
<code>theButton</code>'s <code>clicked</code>
signal to propagate to the given function.
In this case we want to pass an argument,
so we use a C++ &lambda;-expression to call
the this <code>MyWindow</code>'s <code>setString()</code>
method with the desired value.
</p>

<p>
As you can imagine, building a hierarchy of widgets
which send each other signals presents a challenge
with C++'s memory model. Qt is very carefully written
to handle memory very efficiently and seems to be
watertight &mdash; at least I've never experienced
a memory leak that wasn't my fault. It even has a
<code>QObject::deleteLater()</code> method so you
can request the event loop to destroy an object
as soon as it's safe to do so. Of course, the other
way around that is to write in Python, where the
memory-management point is moot.
</p>

</div>

<div class="right">
<h3>Getting Started and Reference</h3>
<p>
Let's write an application!
</p>
<p>
Perhaps more than with any other kind of program,
you should begin by sketching the appearance of what
you want. Here's what I want the main window of my
program to look like.
</p>
<img width="100%" src="qt_sketch-1.png" alt="" />
<p>
The code to create my class, <code>ExecutiveToy</code>
is this:
</p>
<pre class="example">
class ExecutiveToy(QWidget):

    def __init__(self, parent = None):
        super().__init__(parent)
        self.create_UI(parent)
</pre>
<p>
I'm going to break the layout into two rows, so the
main layout manager of my window will be a <code>QVBoxLayout</code>
with two elements:
</p>
<img width="100%" src="qt_sketch-2.png" alt="" />
<p>
The lower of the two rows will contain three elements:
two <code>QPushButtons</code> and some elastic filler
to push the buttons to the outer edge of the window.
That way it will keep a consistent layout if and when
it is resized.
</p>
<img width="100%" src="qt_sketch-3.png" alt="" />
<p>
Let's create the widgets. Continuing the <code>ExecutiveToy</code>
class:
</p>
<pre class="example">
    def create_UI(self, parent):        
        # Create a slider and two buttons
        self.mySlider = QSlider(Qt.Horizontal)
        self.showButton = \
            QPushButton(self.tr('&Show Value'))
        self.quitButton = \
            QPushButton(self.tr('&Quit'))
        
        # No parent: we're going to add this
        # to vLayout.
        hLayout = QHBoxLayout()
        hLayout.addWidget(self.showButton)
        hLayout.addStretch(1)
        hLayout.addWidget(self.quitButton)
        
        # parent = self: this is the
        # "top level" layout
        vLayout = QVBoxLayout(self)
        vLayout.addWidget(self.mySlider)
        vLayout.addLayout(hLayout)  
</pre>
<p>
Now to define the actions. I'm going to do
two things. First I'll connect the clicked
signals of the buttons to their respective
slots, then I'll provide the functions which
will act as slots. PyQt provides
<a href="https://wiki.python.org/moin/PythonDecorators">decorators</a>
to hint to the interpreter that a function is
a slot. If you are expecting your slot to
receive arguments, you can say
<code>@pyqtSlot(int)</code> for example.
</p>

<p>
The <code>quitClicked()</code> method simply
closes the widget; the <code>showClicked()</code>
method creates a modal dialogue box, populates
it with some data from the slider object,
and gives it control.
</p>
<pre class="example">
        self.quitButton.clicked.connect(
            self.quitClicked
        )
        self.showButton.clicked.connect(
            self.showClicked
        )
    
    # Now the slots which accept events
    @pyqtSlot()
    def quitClicked(self):
        self.close()
        
    @pyqtSlot()
    def showClicked(self):
        msg = QMessageBox()
        msg.setIcon(QMessageBox.Information)
    
        msg.setText('Current Slider Value')
        msg.setInformativeText(
            'When requested, value was '
            + str(self.mySlider.value())
        )
        msg.setWindowTitle('mySlider')
        msg.setDetailedText('That is all I know')
        msg.setStandardButtons(QMessageBox.Ok)
    	
        msg.exec()
</pre>
<p>
To make it all work, you'll need to top and tail the code
with the necessary <code>import</code>s and a few lines
to create the application and its window, make the window visible,
then pass control to Qt's event loop until the window is closed,
whereupon the application should exit cleanly. Here is
the appropriate incantation:
</p>
<pre class="example">
import sys
from PyQt5.QtCore import \
    Qt, pyqtSlot
from PyQt5.QtWidgets import \
    QApplication, QWidget, \
    QSlider, QPushButton, \
    QMessageBox, \
    QVBoxLayout, QHBoxLayout
    
...

if __name__ == "__main__":

    app = QApplication(sys.argv)
    window = ExecutiveToy()
    window.show()
    sys.exit(app.exec_())
</pre>
<hr/>

<p><a href="http://zetcode.com/gui/pyqt5/">Zetcode's Introduction to PyQt5</a>
<br/><a href="http://doc.qt.io/qt-5/">Qt5 documentation</a>
<br/><a href="http://pyqt.sourceforge.net/Docs/PyQt5/">PyQt5 documentation</a>
<br/><a href="https://wiki.python.org/moin/PythonDecorators">Python Decorators</a>
</p>

</div>
<div style="margin-bottom:0.5cm;overflow:hidden;text-align:right;clear:left">
<p style="display:inline-block;">Read this next ⇗</p>
<hr/>
</div>

<!--br style="clear:both"/-->







<p><a href="../index.html">Back to main</a></p>

<!-- footer -->
<br style="clear:both"/>

<p>
<a rel="license"
href="http://creativecommons.org/licenses/by-sa/2.5/scotland/"><img
alt="Creative Commons License" style="border-width:0"
src="http://i.creativecommons.org/l/by-sa/2.5/scotland/88x31.png"
/></a>Unless otherwise noted, all materials on these pages
are licenced under a <a rel="license"
href="http://creativecommons.org/licenses/by-sa/2.5/scotland/">Creative
Commons Licence</a>.
</p>


</body>

